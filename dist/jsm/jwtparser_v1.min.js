import{Map as t,StringUtils as e}from"./coreutil_v1.js";class s{constructor(t,e){this.name=t,this.value=e}}class a extends s{static get NAME(){return"aud"}constructor(t){super(a.NAME,t)}get label(){return"Audience"}}class r extends s{static get NAME(){return"exp"}constructor(t){super(r.NAME,t)}get formattedValue(){const t=new Date(1e3*this.value);return t.getFullYear()+"-"+(t.getMonth()+1)+"-"+t.getDate()+" "+t.getHours()+":"+t.getMinutes()+":"+t.getSeconds()}get label(){return"Expiry"}}class n extends s{static get NAME(){return"iss"}constructor(t){super(n.NAME,t)}get label(){return"Issuer"}}class u extends s{static get NAME(){return"jti"}constructor(t){super(u.NAME,t)}get label(){return"JWT Id"}}class l extends s{static get NAME(){return"nbf"}constructor(t){super(l.NAME,t)}get formattedValue(){const t=new Date(1e3*this.value);return t.getFullYear()+"-"+(t.getMonth()+1)+"-"+t.getDate()+" "+t.getHours()+":"+t.getMinutes()+":"+t.getSeconds()}get label(){return"Not Before"}}class i extends s{static get NAME(){return"sub"}constructor(t){super(i.NAME,t)}get label(){return"Subject"}}class o extends s{static get NAME(){return"iat"}constructor(t){super(o.NAME,t)}get formattedValue(){const t=new Date(1e3*this.value);return t.getFullYear()+"-"+(t.getMonth()+1)+"-"+t.getDate()+" "+t.getHours()+":"+t.getMinutes()+":"+t.getSeconds()}get label(){return"Issued at"}}class c extends s{static get NAME(){return"scope"}constructor(t){super(c.NAME,t)}get formattedValue(){return this.value}get label(){return"Scopes"}}class g{constructor(t=null){this.namedClaims=this.asMap(t)}asTypedClaim(t,e){return new e(t)}asMap(e){const s=new t;if(null===e)return s;for(const[t,a]of Object.entries(e))s.set(t,this.asMappedClaim(t,a));return s}getNamedClaim(t){return this.namedClaims.get(t)}getNamedClaimValue(t){return this.namedClaims.get(t)?this.namedClaims.get(t).value:null}asMappedClaim(t,g){return e.nonNullEquals(t,i.NAME)?this.asTypedClaim(g,i):e.nonNullEquals(t,n.NAME)?this.asTypedClaim(g,n):e.nonNullEquals(t,a.NAME)?this.asTypedClaim(g,a):e.nonNullEquals(t,u.NAME)?this.asTypedClaim(g,u):e.nonNullEquals(t,r.NAME)?this.asTypedClaim(g,r):e.nonNullEquals(t,l.NAME)?this.asTypedClaim(g,l):e.nonNullEquals(t,o.NAME)?this.asTypedClaim(g,o):e.nonNullEquals(t,c.NAME)?this.asTypedClaim(g,c):new s(t,g)}get sub(){return this.getNamedClaimValue(i.NAME)}get iss(){return this.getNamedClaimValue(n.NAME)}get aud(){return this.getNamedClaimValue(a.NAME)}get jti(){return this.getNamedClaimValue(u.NAME)}get exp(){return this.getNamedClaimValue(r.NAME)}get nbf(){return this.getNamedClaimValue(l.NAME)}get iat(){return this.getNamedClaimValue(o.NAME)}get scope(){return this.getNamedClaimValue(c.NAME)}}class N extends s{static get NAME(){return"alg"}constructor(t){super(N.NAME,t)}}class M extends s{static get NAME(){return"typ"}constructor(t){super(M.NAME,t)}}class d extends s{static get NAME(){return"kid"}constructor(t){super(d.NAME,t)}}class E{constructor(t){this.algorithm=this.getMeta(t,N.NAME,N),this.type=this.getMeta(t,M.NAME,M),this.kid=this.getMeta(t,d.NAME,d)}getMeta(t,e,s){if(null===t)return null;const a=t[e];return null==a?null:new s(a)}}class m{constructor(t,e,s){this.source=t,this.header=e,this.body=s}}class h{static parseString(t){const e=t.split(".");if(e.length<2)throw"JWT does not have a body";const s=atob(e[0]),a=JSON.parse(s),r=new E(a),n=atob(e[1]),u=JSON.parse(n),l=new g(u);return new m(t,r,l)}}export{N as AlgorithmMeta,a as AudienceClaim,r as ExpiryClaim,o as IssuedAtClaim,n as IssuerClaim,m as Jwt,g as JwtBody,s as JwtEntry,E as JwtHeader,u as JwtIdClaim,h as JwtStringParser,d as KeyIdMeta,l as NotBeforeClaim,c as ScopeClaim,i as SubjectClaim,M as TypeMeta};
